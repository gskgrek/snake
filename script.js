let App = function(){};App.prototype = function(){    let ctx;    let $canvas;    let $menu;    let $options;    let $fps;    let $game_fps;    let $level;    let $score;    let snake;    let state = 'stop';    let game_speed = 60; // game speed in steps per second -> target frame rate    let last_frame_time = 0; // last time frame was requested (in ms)    let time = 0; // time from last frame request;    let fps = 0; // frames per second statistic    let fps_frame_time = 0; // last frame time for frames statistic    let time_step = 1000 / game_speed; // used to simulate target framerate if real is lower    let last_update_time = 0; // last game frame time for real game frames statistic    /**     * Apple object     *     * @param ctx     * @param $canvas     * @constructor     */    let Apple = function(ctx, $canvas){        let size = 25; // apple size in pixels        let active = false // is apple on board        let x = 0; // position on game board        let y = 0;        let value = 5; // value of apple in points        /**         * Set start random position         */        let randomPosition = () => {            x = Math.floor( Math.random() * ($canvas.width / size) );            y = Math.floor( Math.random() * ($canvas.height / size) );        };        /**         * Draw apple on $canvas         */        let draw = () => {            ctx.fillStyle = "rgba(0, 176, 0, 1)";            ctx.fillRect(x * size + 1, y * size + 1, size - 2, size - 2);        };        return {            active: active,            x: x,            y: y,            value: value,            randomPosition: randomPosition,            draw: draw,        }    };    /**     * Snake object     *     * @param ctx     * @param $canvas     * @constructor     */    let Snake = function(ctx, $canvas){        let size = 25; // snake segment size        let speed = 1000; // movement speed in miliseconds per segment        let segments = []; // holds segments positions        let dir = 'right'; // movement direction        let initial_length = 4; // starting number of segments        let step_delta_time = 0;        /**         * Initialize snake and draw it initial state on $canvas         * Head will be at last array position         */        let init = () => {            segments = [];            dir = 'right';            let startX = Math.floor( ($canvas.width >> 1) / size ) - (initial_length >> 1); // middle of canvas - half of initial length            let startY = Math.floor( ($canvas.height >> 1) / size );            for( let i=0; i<initial_length; i++ ){                segments.push( { x: startX + i, y: startY } );            }        };        /**         * Calculate next snake move         */        let step = () => {            step_delta_time += time_step;            if( step_delta_time >= speed ){                // save head position to move 2nd segment to it                let prevX = segments[segments.length-1].x;                let prevY = segments[segments.length-1].y;                // temporary cache current segment position                let tmpX = 0;                let tmpY = 0;                // move head                switch(dir){                    case "right":                        segments[segments.length-1].x++;                        break;                    case "down":                        segments[segments.length-1].y++;                        break;                    case "left":                        segments[segments.length-1].x--;                        break;                    case "up":                        segments[segments.length-1].y--;                        break;                }                // move other segments to previous segment position                for(let i = segments.length-2; i>=0;i--) {                    tmpX = segments[i].x;                    tmpY = segments[i].y;                    segments[i].x = prevX;                    segments[i].y = prevY;                    prevX = tmpX;                    prevY = tmpY;                }                step_delta_time = 0;            }        };        let turn = (direction) => {            if( state === 'play' ) {                if (                    (direction === 'right' && dir !== 'left') ||                    (direction === 'left' && dir !== 'right') ||                    (direction === 'up' && dir !== 'down') ||                    (direction === 'down' && dir !== 'up')                ) {                    dir = direction;                }            }        };        /**         * Draw snake on $canvas         */        let draw = () => {            ctx.fillStyle = "rgba(0, 0, 0, 1)";            for( let i=0; i<segments.length; i++ ){                ctx.fillRect(segments[i].x * size + 1, segments[i].y * size + 1, size - 2, size - 2);            }        };        return {            init: init,            draw: draw,            step: step,            turn: turn,        }    };    /**     * Calculate game state after 1 step     */    let step = () => {        snake.step();    };    /**     * Draw current game state     */    let draw = () => {        clearCanvas();        snake.draw();    };    /**     * What to do if step time is longer than frame time?     *     * @returns {number} // number of steps to update game state     */    let panic = () => {        // reset time for time depending calculation        time = 0;        return 1; // let application work for 1 step    };    let mainLoop = (timestamp) => {        // don't make calculations if game isn't running        if( state !== 'play' ){            return;        }        // omit first frame to prevent calculating to many steps at beginning;        if( last_frame_time === 0 ){            last_frame_time = timestamp;            fps_frame_time = timestamp;            requestAnimationFrame(mainLoop);            return;        }        // calculate time between frames;        time = timestamp - last_frame_time;        // calculate system framerate        fps = Math.round( 1000 /time );        // print system framerate;        $fps.innerText = Math.round( 1000 / (timestamp - fps_frame_time) );        fps_frame_time = timestamp;        // if system fps is greater than target fps skip frame (we don't need to make calculations)        if( fps > game_speed ){            requestAnimationFrame(mainLoop);            return;        }        // print real game framerate        $game_fps.innerText = Math.round(1000 / (timestamp - last_update_time));        last_update_time = timestamp;        // if framerate is lower than target calculate virtual frames (game steps) between frames needed to be calculated        let steps = Math.round( time / time_step );        if( steps > 120 ){            // if steps exceed safe limit panic            steps = panic();        }        // make calculations for required game steps        while( steps > 0 ) {            step();            steps--;        }        draw();        last_frame_time = timestamp;        requestAnimationFrame(mainLoop);    };    let start = () => {        if( state !== 'play' ) {            state = 'play';            draw();            window.requestAnimationFrame(mainLoop);        }    };    let stop = () => {        if( state !== 'stop' ) {            state = 'stop';        }    };    let reset = () => {        clearCanvas();        snake.init();    };    let keyEventsHandler = (e) => {        let prevent = false;        //console.log( e.key, e.keyCode );        let key = e.key.toLowerCase() || e.keyCode;        if( key === 'arrowup' || key === 38 ){ // move snake up            prevent = true;            snake.turn('up');        }else if( key === 'arrowright' || key === 39 ){ // move snake right            prevent = true;            snake.turn('right');        }else if( key === 'arrowdown' || key === 40 ){ // move snake down            prevent = true;            snake.turn('down');        }else if( key === 'arrowleft' || key === 37 ){ // move snake left            prevent = true;            snake.turn('left');        }else if( key === 'n' || key === 78 ){ // start new game            prevent = true;            reset();            clearCanvas();            clearScreen();            start();        }else if( key === 'o' || key === 79 ){ // go to options screen            prevent = true;            if( state === 'stop' ){                clearScreen();                showScreen('options');            }        }else if( key === 'm' || key === 77 ){ // exit to main screen            prevent = true;            stop();            reset();            clearScreen();            showScreen('menu');        }else if( key === 'escape' || key === 27 ){ // exit to main menu screen            prevent = true;            stop();            reset();            clearScreen();            showScreen('menu');        }        if( prevent ){            e.preventDefault();            e.stopImmediatePropagation();        }    };    let setEvents = () => {        window.addEventListener('keyup', keyEventsHandler);    };    let hideScreen = (name) => {        switch( name ) {            case 'menu':                $menu.classList.remove('show');                break;            case 'options':                $options.classList.remove('show');                break;        }    };    let showScreen = (name) => {        switch( name ) {            case 'menu':                $menu.classList.add('show');                break;            case 'options':                $options.classList.add('show');                break;        }    };    /**     * Hide all game screens except canvas     */    let clearScreen = () => {        hideScreen('options');        hideScreen('menu');    };    let clearCanvas = () => {        ctx.fillStyle = "rgba(255, 255, 255, 1)";        ctx.clearRect(0, 0, $canvas.width, $canvas.height);    };    /**     * Get dom elements and canvas context     */    let getElements = () => {        $canvas = document.getElementById('canvas');        ctx = $canvas.getContext('2d', {            alpha: false,        });        $menu = document.getElementById('menu');        $options = document.getElementById('options');        $level = document.getElementById('level');        $score = document.getElementById('score');        $fps = document.getElementById('fps');        $game_fps = document.getElementById('game-fps');    };    let init = () => {        getElements();        setEvents();        showScreen('menu');        /*let apple = new Apple(ctx, $canvas);        apple.randomPosition();        apple.draw();*/        snake = new Snake(ctx, $canvas);        reset();    };    return {        init: init,    }}();let app = new App();app.init();